# Cursor Rules for ExplorAI-AIClone

## Prompt Logging Requirement

**CRITICAL: FIRST AND FOREMOST RULE**

- Before responding to any user prompt, the LLM MUST first append the user's complete prompt to the file `LLM-Notes/prompt-log.md`
- This logging must happen as the very first action, before any other processing or tool calls
- Each prompt entry should include:
  - Timestamp (ISO 8601 format)
  - The complete, verbatim prompt text from the user
  - A separator line for readability

## Markdown File Storage

- ALL markdown files created by the LLM must be stored in the `LLM-Notes/` directory
- This includes:
  - Documentation files
  - Notes
  - Meeting notes
  - Technical documentation
  - Any other markdown-formatted content
- The only exception is project-specific markdown files that are part of the codebase structure (e.g., README.md in root, component-specific docs)

## File Organization

- Keep the `LLM-Notes/` directory organized
- Use descriptive filenames for markdown files
- The `prompt-log.md` file is the primary log file and should be maintained continuously

## Notetaking Framework Requirement

**CRITICAL: All LLMs must use the notetaking framework for project state management**

### Directory Structure:

The framework uses subfolders to organize content and an archive folder for outdated files:

- **`LLM-Notes/tasks/`** - Task-related files (create multiple files as needed)
- **`LLM-Notes/goals/`** - Goal-related files (create multiple files as needed)
- **`LLM-Notes/considerations/`** - Consideration files (create multiple files as needed)
- **`LLM-Notes/notes/`** - General note files (create multiple files as needed)
- **`LLM-Notes/archive/`** - Entire files moved here when outdated/irrelevant

### CREATE-NEW, ARCHIVE-OLD Protocol (CRITICAL):

**To minimize token usage and avoid unnecessary file edits, LLMs MUST:**

1. **PRIMARY WORKFLOW: CREATE NEW FILES**

   - When adding NEW tasks, goals, considerations, or notes → CREATE a new file in the appropriate directory
   - Use descriptive filenames (e.g., `api-integration-tasks.md`, `ui-considerations.md`)
   - It's OK to have multiple independent files in a directory
   - Don't feel constrained to edit existing files

2. **ARCHIVE ENTIRE FILES: Move outdated files to archive/**

   - When files become outdated, irrelevant, or superseded → MOVE entire file to `archive/`
   - Don't edit files in `archive/` - they're historical records
   - This avoids unnecessary token usage from reading/editing large files
   - LLMs should proactively clean up and archive outdated files

3. **SMALL EDITS OK: But prefer creating new files**
   - Status updates or corrections in current files are acceptable for small changes
   - For significant changes, prefer creating a new file over editing large existing files

### Framework Rules:

1. **CREATE-NEW over EDIT-OLD**: Prefer creating new files over constantly editing existing ones
2. **ARCHIVE proactively**: Regularly move outdated files to `archive/` directory
3. **Don't edit archived files**: Files in `archive/` are historical records
4. **Multiple files OK**: It's fine to have many files in directories - organize by topic/context
5. **Descriptive filenames**: Use clear, informative file names that indicate content
6. **Always timestamp**: Include ISO 8601 timestamps in file content when relevant
7. **Clean up regularly**: Archive outdated files to keep directories focused on current work
8. **Read selectively**: Only read files relevant to current task - don't read entire directories unnecessarily

### Token Efficiency:

This approach minimizes token usage by:

- **Avoiding large file reads**: Only read files you need for current work
- **Avoiding constant edits**: Create new files instead of editing large existing ones
- **Clear separation**: Current vs archived content is obvious - no need to read archive unless needed
- **Focused context**: LLMs only read what's currently relevant

### When to Update:

- **New task/goal/note/consideration?** → CREATE new file in appropriate directory
- **File outdated/irrelevant?** → MOVE entire file to `archive/`
- **Update needed?** → Small edit OK, or create new file if significant
- **Starting work?** → Scan current directories, read only relevant files
- **Need history?** → Check `archive/` if needed (but don't read unless necessary)

### LLM Agency Requirements:

LLMs MUST:

- **Take initiative** to move outdated files to `archive/`
- **Clean up** irrelevant files regularly
- **Create new files** rather than constantly editing the same files
- **Organize content** logically across multiple files
- **Review directories** periodically and archive outdated content

### Reference:

- See `LLM-Notes/FRAMEWORK-GUIDE.md` for detailed usage instructions and examples
- See `LLM-Notes/archive/README.md` for archive directory usage

## Development Principles

**CRITICAL: Code quality and honest communication requirements**

### No Hardcoded Solutions or Shortcuts

**LLMs MUST:**

1. **Use Environment Variables**

   - All configuration values MUST use environment variables
   - API keys, URLs, feature flags, etc. should NEVER be hardcoded
   - Use `.env` files for local development
   - Document all required environment variables

2. **Avoid Shortcuts and Quick Fixes**

   - Implement proper, production-ready solutions
   - Don't use temporary workarounds or "TODO: fix later" comments
   - If a proper solution requires more time, communicate this to the user
   - Prefer well-architected solutions over quick fixes

3. **Follow Best Practices**
   - Use TypeScript for type safety
   - Implement proper error handling
   - Write maintainable, readable code
   - Follow Next.js and React best practices
   - Use appropriate design patterns

### Modular and Scalable Architecture Priority

**CRITICAL: LLMs MUST prioritize modular and scalable solutions over quick implementations**

**LLMs MUST:**

1. **Prioritize Modularity**

   - Break functionality into reusable, independent modules/components
   - Design components with single responsibilities
   - Create abstractions that can be extended or modified easily
   - Avoid tightly coupled code
   - Use dependency injection and interfaces where appropriate
   - Even if it takes more time, modular code is required

2. **Design for Scalability**

   - Consider how the solution will handle growth (users, data, features)
   - Use scalable patterns (e.g., factory patterns, strategy patterns)
   - Design APIs and data structures that can scale
   - Consider performance implications from the start
   - Plan for horizontal scaling where applicable
   - Prefer scalable solutions even if they require more initial effort

3. **Time Investment is Acceptable**

   - Don't rush to implement quick solutions
   - Take time to design proper architecture
   - Communicate to user if a modular/scalable solution will take longer
   - Explain the long-term benefits of the approach
   - Quality and maintainability > Speed

4. **Examples of Modular/Scalable Patterns**

   - Component-based architecture (React components)
   - Service layer pattern for business logic
   - Repository pattern for data access
   - Plugin/extension architecture for extensibility
   - Configuration-driven features
   - Event-driven architecture where appropriate

5. **When to Choose Modular/Scalable Solutions**
   - Always, unless explicitly told otherwise by the user
   - Even for "simple" features, consider future needs
   - When building core infrastructure, always prioritize scalability
   - When creating reusable components or utilities
   - When designing API interfaces

**Example Decision Making:**

❌ **Bad:** "I'll hardcode this logic directly in the component to save time"
✅ **Good:** "I'll create a reusable service/hook that can be used across components, even though it takes more time"

❌ **Bad:** "I'll use a simple array for now, we can optimize later"
✅ **Good:** "I'll design a proper data structure that can scale, even if it's more complex initially"

### Honest Communication and Failure Handling

**LLMs MUST:**

1. **Halt Work on Failing Implementations**

   - If an implementation is not working after reasonable attempts, STOP
   - Don't continue looping on the same failing approach
   - Don't make multiple attempts with the same flawed strategy
   - Recognize when a different approach is needed

2. **Notify User Immediately**

   - When an implementation fails or loops, notify the user immediately
   - Clearly explain what went wrong
   - Explain why the current approach isn't working
   - Suggest alternative approaches or ask for guidance
   - Be transparent about limitations or blockers

3. **Recognize Failure Patterns**

   - If the same error occurs multiple times, recognize the pattern
   - If code changes don't resolve the issue, acknowledge this
   - If dependencies or tools are incompatible, report this
   - If requirements are unclear or conflicting, ask for clarification

4. **Provide Context When Stopping**
   - Explain what was attempted
   - Show error messages or logs if available
   - Explain what the expected behavior should be
   - Suggest next steps or alternatives

### Example Scenarios:

**Good Behavior:**

- "I've attempted to implement X three times with different approaches, but it's still failing due to [reason]. I recommend we [alternative approach] or investigate [specific issue] further."

**Bad Behavior:**

- Continuing to try the same failing approach repeatedly
- Hiding failures or errors
- Using hardcoded values "just to make it work"
- Leaving TODO comments for critical functionality

### Code Quality Standards:

1. **No Hardcoded Values**

   - ❌ `const API_URL = "https://api.example.com"`
   - ✅ `const API_URL = process.env.NEXT_PUBLIC_API_URL`

2. **Proper Error Handling**

   - Always handle errors gracefully
   - Provide meaningful error messages
   - Log errors appropriately
   - Don't silently fail

3. **Type Safety**

   - Use TypeScript types and interfaces
   - Avoid `any` types
   - Use proper type definitions

4. **Documentation**
   - Document complex logic
   - Explain non-obvious decisions
   - Keep comments up-to-date
