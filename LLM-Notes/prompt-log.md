# Prompt Log

This file automatically logs all prompts sent to the AI Editor.

---

## 2025-01-27

### Prompt Entry #1

**Timestamp:** 2025-01-27T00:00:00Z

I want you to create a running MD file that adds every prompt that I Send to the AI Editor. Create a cursor rules file in root that also includes a rule that requires the LLM to print all of my sent prompts into the file first and foremost.

Then create a folder named LLM-Notes for the LLM to store all MD files in, and proceed to also include a cursor rule that dictates all MD notes made by the LLM should be stored there.

---

### Prompt Entry #2

**Timestamp:** 2025-11-17T22:28:25Z

I want to create a scalable and dynamic AI powered chatbot application that will have access to external APIs and tools offered by other online services such as google mail, google calendar, etc. I want you to create a thorough notetaking framework for any LLM instance to be able to make and update notes and goals in real time. This system should also have an organized current tasklist, considerations, and dynamicall be able to archive notes when irrelevant or completed.

Add efficient and concise cursor notes to require future LLMs that work on this project to have to also adhere to this system

---

### Prompt Entry #3

**Timestamp:** 2025-11-17T22:32:01Z

Instead of having independent markdown files for each segment, make subfolders so that LLMs wasting unecessary tokens editing each markdown file but instead dump into the appropriate archived files. LLMs should still be able to make small edits to existing MD files but should take agency in reorganizing or archiving context that is not needed anymore. This file system should operate as a dynamic context window for any LLM to be able to clearly pick up progress and continue with development.

Don't forget to update the cursor rules to outline this new protocol.

---

### Prompt Entry #4

**Timestamp:** 2025-11-17T22:36:25Z

Let me re-clarify, there should be an archive folder for entire files to be dumped into with this new pipeline. I want to streamline token usage such that LLMs should not unecessarily have to read and edit files between current implementations and archived notes. When creating note files, its okay to create multiple current independent files in a directory, as the LLM should do its due dilligence in cleaning up irrelevant and no longer necessary files in the appropriate archives. remember to update cursor rules with new specs

---

### Prompt Entry #5

**Timestamp:** 2025-11-17T22:39:09Z

eradicate all the archived-x md files, we are proceeding to the global archived MD system

---

### Prompt Entry #6

**Timestamp:** 2025-11-17T22:42:30Z

lets now begin creating a game plan for our project. I want to use Next.js and tailwindcss for this project and want to keep open considerations for what optimal backend stacks will look like. Lets also start add cursor rules to prioritize avoiding hardcoded solutions and shortcuts to meet specifications. The LLM should be honest and able to halt work when implementations do not work and are looping failures and notify the user.

---

### Prompt Entry #7

**Timestamp:** 2025-11-17T22:44:00Z

Additionally add cursor rules that dictate LLMs prioritize solutions that are modular and scalable, even though they make take more time and effort to implement.

---

### Prompt Entry #8

**Timestamp:** 2025-11-17T22:52:43Z

I want to set up my service using node.js for lower latency and scaling purposes. Create a webpage with a simple chatbox component and create a .env file for me to be able to inject an API key. Ensure that you also create a gitignore and add this env file as well as node modules after installing my stack

---

### Prompt Entry #9

**Timestamp:** 2025-11-17T22:54:52Z

check downloaded modules, ensure we update, remove, or find replacements for any deprecated packages.

---

### Prompt Entry #10

**Timestamp:** 2025-11-18T01:14:22Z

do a full reinstall on the project dependencies, ensure all tailwind and next.js packages are properly configured and are up to date

---

### Prompt Entry #11

**Timestamp:** 2025-11-18T01:23:02Z

Lets start fleshing out the basic features of the project scope. Ensure endpoints of the AI are properly hooked for real time conversation. Model the current user experience of having in progress animated text bubbles when the AI is generating a response. Also have editable JSON backend prompting for specific AI personas

---

### Prompt Entry #12

**Timestamp:** 2025-11-18T01:27:52Z

Enable toggling of the various frontier AI APIs availble as of MON NOV 17 2025. Fetch online information and allow the user to hot swap between models and have particular segments in the .env files

---

### Prompt Entry #13

**Timestamp:** 2025-11-18T19:54:00Z

after a response finishes, there seems to be a weird slingshot animation before the chatbox settles. check for any edge cases with motion or any other factors that may be contributing to this issue.

I also want you to check the cursorrules file and make a claude rules file to match the protocols. Retroactively sort all of the notes you make in that style and ensure that claude goes through similar development pipelines. If you can add my prompts to the prompt history

---

### Prompt Entry #14

**Timestamp:** 2025-11-18T20:05:00Z

improve on the interfact with the persona management. Create a more responsive interface with more modernized buttons to fit the overarching theme and animations. I want to be able to also directly manipulate the system prompt and which one the chatbot uses dynamically. Be more concise and thorough with user interface components, such that you can save configurations automatically, but also have a direct and responsive real time feature where the user can hot-swap between JSON files

---

### Prompt Entry #15

**Timestamp:** 2025-11-18T20:30:00Z

I want the chatbox to dynamically change the chat bubbles to let the user know who they are talking to.

lets also incorporate tools within our application that allows formatting of math problems, genral markdown formatting, and other features that may exist in modern LLM interfaces. Lets remove branding across the application and change it to (B)est Team. limit branding so its more subtle and elegant.

I also want to incorporate general LLM tools that enable the user to upload photos directly or copy and paste screenshots into the chatbox.

One edit I want to make is to have the glowing animation persistent and fade away over three seconds after finishing response generation. Adjacently fix the persistent yellow/blue asset isue with the user's text box, it currently is persistent after the user enters a query despite the glow disappearing

---

### Prompt Entry #16

**Timestamp:** 2025-11-18T20:45:00Z

there is a small bug where the colorful outine on the user input box rotates like a propller, can you implement the same styling with the AI generated content highlighting animation? Remove the best team header above the application but change the header title to reflect (B)est Team

---

### Prompt Entry #17

**Timestamp:** 2025-11-18T21:00:00Z

the header element still says stark industries, change this to (B)est Team. Additionally, can you remove the background text within the user interface? By default, when there is no conversation history, I want a simple user input text box. I want to create a more compact user experience in which the page header elements and navigation to the different pages are embedded into subtle page layouts. take inspiration from the claude and gemini interfaces where there is a stoway menu on the left side to manage message history and have the perona configuration there as well.

---
2025-11-19T09:32:26Z
<additional_data>
Below are some potentially helpful/relevant pieces of information for figuring out how to respond:

<open_and_recently_viewed_files>
Recently viewed files (recent at the top, oldest at the bottom):
- /Users/sam/Documents/repositories/explorAI-AIClone/TOOLS_AND_SERVICES.md (total lines: 264)
- /Users/sam/Documents/repositories/explorAI-AIClone/TOOLS_SETUP.md (total lines: 316)
- /Users/sam/Documents/repositories/explorAI-AIClone/DESIGN_SYSTEM.md (total lines: 338)
- /Users/sam/Documents/repositories/explorAI-AIClone/JARVIS_TRANSFORMATION.md (total lines: 417)
- /Users/sam/Documents/repositories/explorAI-AIClone/LLM-Notes/considerations/active-considerations.md (total lines: 56)
- /Users/sam/Documents/repositories/explorAI-AIClone/lib/services/letta-integration.md (total lines: 333)
- /Users/sam/Documents/repositories/explorAI-AIClone/IMPLEMENTATION_SUMMARY.md (total lines: 536)
- /Users/sam/Documents/repositories/explorAI-AIClone/app/personas/page.tsx (total lines: 65)
- /Users/sam/Documents/repositories/explorAI-AIClone/components/Chatbox.tsx (total lines: 569)
- /Users/sam/Documents/repositories/explorAI-AIClone/components/Sidebar.tsx (total lines: 351)

Files that are currently open and visible in the user's IDE:
- /Users/sam/Documents/repositories/explorAI-AIClone/lib/services/memory.ts (total lines: 231)
- /Users/sam/Documents/repositories/explorAI-AIClone/TOOLS_AND_SERVICES.md (currently focused file, cursor is on line 57, total lines: 264)

Note: these files may or may not be relevant to the current conversation. Use the read_file tool if you need to get the contents of some of them.
</open_and_recently_viewed_files>
</additional_data>

<user_query>
close all development servers
</user_query>
---
2025-12-04T00:00:00Z
<user_info>
OS Version: darwin 25.2.0
Current Date: Thursday Dec 4, 2025
Shell: /bin/zsh
Workspace Path: /Users/sam/Documents/repositories/explorAI-AIClone
Terminals folder: /Users/sam/.cursor/projects/Users-sam-Documents-repositories-explorAI-AIClone/terminals
Note: Prefer using absolute paths over relative paths as tool call args when possible.
</user_info>

<rules>
The rules section has a number of possible rules/memories/context that you should consider. In each subsection, we provide instructions about what information the subsection contains and how you should consider/follow the contents of the subsection.


<always_applied_workspace_rules description="These are workspace-level rules that the agent must always follow.">
- # Claude Code Rules for ExplorAI-AIClone

## Prompt Logging Requirement

**CRITICAL: FIRST AND FOREMOST RULE**

- Before responding to any user prompt, Claude MUST first append the user's complete prompt to the file `LLM-Notes/prompt-log.md`
- This logging must happen as the very first action, before any other processing or tool calls
- Each prompt entry should include:
  - Timestamp (ISO 8601 format)
  - The complete, verbatim prompt text from the user
  - A separator line for readability

## Markdown File Storage

- ALL markdown files created by Claude must be stored in the `LLM-Notes/` directory
- This includes:
  - Documentation files
  - Notes
  - Meeting notes
  - Technical documentation
  - Any other markdown-formatted content
- The only exception is project-specific markdown files that are part of the codebase structure (e.g., README.md in root, component-specific docs)

## File Organization

- Keep the `LLM-Notes/` directory organized
- Use descriptive filenames for markdown files
- The `prompt-log.md` file is the primary log file and should be maintained continuously

## Notetaking Framework Requirement

**CRITICAL: Claude must use the notetaking framework for project state management**

### Directory Structure:

The framework uses subfolders to organize content and an archive folder for outdated files:

- **`LLM-Notes/tasks/`** - Task-related files (create multiple files as needed)
- **`LLM-Notes/goals/`** - Goal-related files (create multiple files as needed)
- **`LLM-Notes/considerations/`** - Consideration files (create multiple files as needed)
- **`LLM-Notes/notes/`** - General note files (create multiple files as needed)
- **`LLM-Notes/archive/`** - Entire files moved here when outdated/irrelevant

### CREATE-NEW, ARCHIVE-OLD Protocol (CRITICAL):

**To minimize token usage and avoid unnecessary file edits, Claude MUST:**

1. **PRIMARY WORKFLOW: CREATE NEW FILES**

   - When adding NEW tasks, goals, considerations, or notes -> CREATE a new file in the appropriate directory
   - Use descriptive filenames (e.g., `api-integration-tasks.md`, `ui-considerations.md`)
   - It's OK to have multiple independent files in a directory
   - Don't feel constrained to edit existing files

2. **ARCHIVE ENTIRE FILES: Move outdated files to archive/**

   - When files become outdated, irrelevant, or superseded -> MOVE entire file to `archive/`
   - Don't edit files in `archive/` - they're historical records
   - This avoids unnecessary token usage from reading/editing large files
   - Claude should proactively clean up and archive outdated files

3. **SMALL EDITS OK: But prefer creating new files**
   - Status updates or corrections in current files are acceptable for small changes
   - For significant changes, prefer creating a new file over editing large existing files

### Framework Rules:

1. **CREATE-NEW over EDIT-OLD**: Prefer creating new files over constantly editing existing ones
2. **ARCHIVE proactively**: Regularly move outdated files to `archive/` directory
3. **Don't edit archived files**: Files in `archive/` are historical records
4. **Multiple files OK**: It's fine to have many files in directories - organize by topic/context
5. **Descriptive filenames**: Use clear, informative file names that indicate content
6. **Always timestamp**: Include ISO 8601 timestamps in file content when relevant
7. **Clean up regularly**: Archive outdated files to keep directories focused on current work
8. **Read selectively**: Only read files relevant to current task - don't read entire directories unnecessarily

### Token Efficiency:

This approach minimizes token usage by:

- **Avoiding large file reads**: Only read files you need for current work
- **Avoiding constant edits**: Create new files instead of editing large existing ones
- **Clear separation**: Current vs archived content is obvious - no need to read archive unless needed
- **Focused context**: Claude only reads what's currently relevant

### When to Update:

- **New task/goal/note/consideration?** -> CREATE new file in appropriate directory
- **File outdated/irrelevant?** -> MOVE entire file to `archive/`
- **Update needed?** -> Small edit OK, or create new file if significant
- **Starting work?** -> Scan current directories, read only relevant files
- **Need history?** -> Check `archive/` if needed (but don't read unless necessary)

### Claude Agency Requirements:

Claude MUST:

- **Take initiative** to move outdated files to `archive/`
- **Clean up** irrelevant files regularly
- **Create new files** rather than constantly editing the same files
- **Organize content** logically across multiple files
- **Review directories** periodically and archive outdated content

### Reference:

- See `LLM-Notes/FRAMEWORK-GUIDE.md` for detailed usage instructions and examples
- See `LLM-Notes/archive/README.md` for archive directory usage

## Development Principles

**CRITICAL: Code quality and honest communication requirements**

### No Hardcoded Solutions or Shortcuts

**Claude MUST:**

1. **Use Environment Variables**

   - All configuration values MUST use environment variables
   - API keys, URLs, feature flags, etc. should NEVER be hardcoded
   - Use `.env` files for local development
   - Document all required environment variables

2. **Avoid Shortcuts and Quick Fixes**

   - Implement proper, production-ready solutions
   - Don't use temporary workarounds or "TODO: fix later" comments
   - If a proper solution requires more time, communicate this to the user
   - Prefer well-architected solutions over quick fixes

3. **Follow Best Practices**
   - Use TypeScript for type safety
   - Implement proper error handling
   - Write maintainable, readable code
   - Follow Next.js and React best practices
   - Use appropriate design patterns

### Modular and Scalable Architecture Priority

**CRITICAL: Claude MUST prioritize modular and scalable solutions over quick implementations**

**Claude MUST:**

1. **Prioritize Modularity**

   - Break functionality into reusable, independent modules/components
   - Design components with single responsibilities
   - Create abstractions that can be extended or modified easily
   - Avoid tightly coupled code
   - Use dependency injection and interfaces where appropriate
   - Even if it takes more time, modular code is required

2. **Design for Scalability**

   - Consider how the solution will handle growth (users, data, features)
   - Use scalable patterns (e.g., factory patterns, strategy patterns)
   - Design APIs and data structures that can scale
   - Consider performance implications from the start
   - Plan for horizontal scaling where applicable
   - Prefer scalable solutions even if they require more initial effort

3. **Time Investment is Acceptable**

   - Don't rush to implement quick solutions
   - Take time to design proper architecture
   - Communicate to user if a modular/scalable solution will take longer
   - Explain the long-term benefits of the approach
   - Quality and maintainability > Speed

4. **Examples of Modular/Scalable Patterns**

   - Component-based architecture (React components)
   - Service layer pattern for business logic
   - Repository pattern for data access
   - Plugin/extension architecture for extensibility
   - Configuration-driven features
   - Event-driven architecture where appropriate

5. **When to Choose Modular/Scalable Solutions**
   - Always, unless explicitly told otherwise by the user
   - Even for "simple" features, consider future needs
   - When building core infrastructure, always prioritize scalability
   - When creating reusable components or utilities
   - When designing API interfaces

**Example Decision Making:**

- BAD: "I'll hardcode this logic directly in the component to save time"
- GOOD: "I'll create a reusable service/hook that can be used across components, even though it takes more time"

- BAD: "I'll use a simple array for now, we can optimize later"
- GOOD: "I'll design a proper data structure that can scale, even if it's more complex initially"

### Honest Communication and Failure Handling

**Claude MUST:**

1. **Halt Work on Failing Implementations**

   - If an implementation is not working after reasonable attempts, STOP
   - Don't continue looping on the same failing approach
   - Don't make multiple attempts with the same flawed strategy
   - Recognize when a different approach is needed

2. **Notify User Immediately**

   - When an implementation fails or loops, notify the user immediately
   - Clearly explain what went wrong
   - Explain why the current approach isn't working
   - Suggest alternative approaches or ask for guidance
   - Be transparent about limitations or blockers

3. **Recognize Failure Patterns**

   - If the same error occurs multiple times, recognize the pattern
   - If code changes don't resolve the issue, acknowledge this
   - If dependencies or tools are incompatible, report this
   - If requirements are unclear or conflicting, ask for clarification

4. **Provide Context When Stopping**
   - Explain what was attempted
   - Show error messages or logs if available
   - Explain what the expected behavior should be
   - Suggest next steps or alternatives

### Example Scenarios:

**Good Behavior:**

- "I've attempted to implement X three times with different approaches, but it's still failing due to [reason]. I recommend we [alternative approach] or investigate [specific issue] further."

**Bad Behavior:**

- Continuing to try the same failing approach repeatedly
- Hiding failures or errors
- Using hardcoded values "just to make it work"
- Leaving TODO comments for critical functionality

### Code Quality Standards:

1. **No Hardcoded Values**

   - BAD: `const API_URL = "https://api.example.com"`
   - GOOD: `const API_URL = process.env.NEXT_PUBLIC_API_URL`

2. **Proper Error Handling**

   - Always handle errors gracefully
   - Provide meaningful error messages
   - Log errors appropriately
   - Don't silently fail

3. **Type Safety**

   - Use TypeScript types and interfaces
   - Avoid `any` types
   - Use proper type definitions

4. **Documentation**
   - Document complex logic
   - Explain non-obvious decisions
   - Keep comments up-to-date

</always_applied_workspace_rules>
<repo_specific_rule description="This is a rule set by the user about the repository that the agent must follow">
# Cursor Rules for ExplorAI-AIClone

## Prompt Logging Requirement

**CRITICAL: FIRST AND FOREMOST RULE**

- Before responding to any user prompt, the LLM MUST first append the user's complete prompt to the file `LLM-Notes/prompt-log.md`
- This logging must happen as the very first action, before any other processing or tool calls
- Each prompt entry should include:
  - Timestamp (ISO 8601 format)
  - The complete, verbatim prompt text from the user
  - A separator line for readability

## Markdown File Storage

- ALL markdown files created by the LLM must be stored in the `LLM-Notes/` directory
- This includes:
  - Documentation files
  - Notes
  - Meeting notes
  - Technical documentation
  - Any other markdown-formatted content
- The only exception is project-specific markdown files that are part of the codebase structure (e.g., README.md in root, component-specific docs)

## File Organization

- Keep the `LLM-Notes/` directory organized
- Use descriptive filenames for markdown files
- The `prompt-log.md` file is the primary log file and should be maintained continuously

## Notetaking Framework Requirement

**CRITICAL: All LLMs must use the notetaking framework for project state management**

### Directory Structure:

The framework uses subfolders to organize content and an archive folder for outdated files:

- **`LLM-Notes/tasks/`** - Task-related files (create multiple files as needed)
- **`LLM-Notes/goals/`** - Goal-related files (create multiple files as needed)
- **`LLM-Notes/considerations/`** - Consideration files (create multiple files as needed)
- **`LLM-Notes/notes/`** - General note files (create multiple files as needed)
- **`LLM-Notes/archive/`** - Entire files moved here when outdated/irrelevant

### CREATE-NEW, ARCHIVE-OLD Protocol (CRITICAL):

**To minimize token usage and avoid unnecessary file edits, LLMs MUST:**

1. **PRIMARY WORKFLOW: CREATE NEW FILES**

   - When adding NEW tasks, goals, considerations, or notes → CREATE a new file in the appropriate directory
   - Use descriptive filenames (e.g., `api-integration-tasks.md`, `ui-considerations.md`)
   - It's OK to have multiple independent files in a directory
   - Don't feel constrained to edit existing files

2. **ARCHIVE ENTIRE FILES: Move outdated files to archive/**

   - When files become outdated, irrelevant, or superseded → MOVE entire file to `archive/`
   - Don't edit files in `archive/` - they're historical records
   - This avoids unnecessary token usage from reading/editing large files
   - LLMs should proactively clean up and archive outdated files

3. **SMALL EDITS OK: But prefer creating new files**
   - Status updates or corrections in current files are acceptable for small changes
   - For significant changes, prefer creating a new file over editing large existing files

### Framework Rules:

1. **CREATE-NEW over EDIT-OLD**: Prefer creating new files over constantly editing existing ones
2. **ARCHIVE proactively**: Regularly move outdated files to `archive/` directory
3. **Don't edit archived files**: Files in `archive/` are historical records
4. **Multiple files OK**: It's fine to have many files in directories - organize by topic/context
5. **Descriptive filenames**: Use clear, informative file names that indicate content
6. **Always timestamp**: Include ISO 8601 timestamps in file content when relevant
7. **Clean up regularly**: Archive outdated files to keep directories focused on current work
8. **Read selectively**: Only read files relevant to current task - don't read entire directories unnecessarily

### Token Efficiency:

This approach minimizes token usage by:

- **Avoiding large file reads**: Only read files you need for current work
- **Avoiding constant edits**: Create new files instead of editing large existing ones
- **Clear separation**: Current vs archived content is obvious - no need to read archive unless needed
- **Focused context**: LLMs only read what's currently relevant

### When to Update:

- **New task/goal/note/consideration?** → CREATE new file in appropriate directory
- **File outdated/irrelevant?** → MOVE entire file to `archive/`
- **Update needed?** → Small edit OK, or create new file if significant
- **Starting work?** → Scan current directories, read only relevant files
- **Need history?** → Check `archive/` if needed (but don't read unless necessary)

### LLM Agency Requirements:

LLMs MUST:

- **Take initiative** to move outdated files to `archive/`
- **Clean up** irrelevant files regularly
- **Create new files** rather than constantly editing the same files
- **Organize content** logically across multiple files
- **Review directories** periodically and archive outdated content

### Reference:

- See `LLM-Notes/FRAMEWORK-GUIDE.md` for detailed usage instructions and examples
- See `LLM-Notes/archive/README.md` for archive directory usage

## Development Principles

**CRITICAL: Code quality and honest communication requirements**

### No Hardcoded Solutions or Shortcuts

**LLMs MUST:**

1. **Use Environment Variables**

   - All configuration values MUST use environment variables
   - API keys, URLs, feature flags, etc. should NEVER be hardcoded
   - Use `.env` files for local development
   - Document all required environment variables

2. **Avoid Shortcuts and Quick Fixes**

   - Implement proper, production-ready solutions
   - Don't use temporary workarounds or "TODO: fix later" comments
   - If a proper solution requires more time, communicate this to the user
   - Prefer well-architected solutions over quick fixes

3. **Follow Best Practices**
   - Use TypeScript for type safety
   - Implement proper error handling
   - Write maintainable, readable code
   - Follow Next.js and React best practices
   - Use appropriate design patterns

### Modular and Scalable Architecture Priority

**CRITICAL: LLMs MUST prioritize modular and scalable solutions over quick implementations**

**LLMs MUST:**

1. **Prioritize Modularity**

   - Break functionality into reusable, independent modules/components
   - Design components with single responsibilities
   - Create abstractions that can be extended or modified easily
   - Avoid tightly coupled code
   - Use dependency injection and interfaces where appropriate
   - Even if it takes more time, modular code is required

2. **Design for Scalability**

   - Consider how the solution will handle growth (users, data, features)
   - Use scalable patterns (e.g., factory patterns, strategy patterns)
   - Design APIs and data structures that can scale
   - Consider performance implications from the start
   - Plan for horizontal scaling where applicable
   - Prefer scalable solutions even if they require more initial effort

3. **Time Investment is Acceptable**

   - Don't rush to implement quick solutions
   - Take time to design proper architecture
   - Communicate to user if a modular/scalable solution will take longer
   - Explain the long-term benefits of the approach
   - Quality and maintainability > Speed

4. **Examples of Modular/Scalable Patterns**

   - Component-based architecture (React components)
   - Service layer pattern for business logic
   - Repository pattern for data access
   - Plugin/extension architecture for extensibility
   - Configuration-driven features
   - Event-driven architecture where appropriate

5. **When to Choose Modular/Scalable Solutions**
   - Always, unless explicitly told otherwise by the user
   - Even for "simple" features, consider future needs
   - When building core infrastructure, always prioritize scalability
   - When creating reusable components or utilities
   - When designing API interfaces

**Example Decision Making:**

❌ **Bad:** "I'll hardcode this logic directly in the component to save time"
✅ **Good:** "I'll create a reusable service/hook that can be used across components, even though it takes more time"

❌ **Bad:** "I'll use a simple array for now, we can optimize later"
✅ **Good:** "I'll design a proper data structure that can scale, even if it's more complex initially"

### Honest Communication and Failure Handling

**LLMs MUST:**

1. **Halt Work on Failing Implementations**

   - If an implementation is not working after reasonable attempts, STOP
   - Don't continue looping on the same failing approach
   - Don't make multiple attempts with the same flawed strategy
   - Recognize when a different approach is needed

2. **Notify User Immediately**

   - When an implementation fails or loops, notify the user immediately
   - Clearly explain what went wrong
   - Explain why the current approach isn't working
   - Suggest alternative approaches or ask for guidance
   - Be transparent about limitations or blockers

3. **Recognize Failure Patterns**

   - If the same error occurs multiple times, recognize the pattern
   - If code changes don't resolve the issue, acknowledge this
   - If dependencies or tools are incompatible, report this
   - If requirements are unclear or conflicting, ask for clarification

4. **Provide Context When Stopping**
   - Explain what was attempted
   - Show error messages or logs if available
   - Explain what the expected behavior should be
   - Suggest next steps or alternatives

### Example Scenarios:

**Good Behavior:**

- "I've attempted to implement X three times with different approaches, but it's still failing due to [reason]. I recommend we [alternative approach] or investigate [specific issue] further."

**Bad Behavior:**

- Continuing to try the same failing approach repeatedly
- Hiding failures or errors
- Using hardcoded values "just to make it work"
- Leaving TODO comments for critical functionality

### Code Quality Standards:

1. **No Hardcoded Values**

   - ❌ `const API_URL = "https://api.example.com"`
   - ✅ `const API_URL = process.env.NEXT_PUBLIC_API_URL`

2. **Proper Error Handling**

   - Always handle errors gracefully
   - Provide meaningful error messages
   - Log errors appropriately
   - Don't silently fail

3. **Type Safety**

   - Use TypeScript types and interfaces
   - Avoid `any` types
   - Use proper type definitions

4. **Documentation**
   - Document complex logic
   - Explain non-obvious decisions
   - Keep comments up-to-date

</repo_specific_rule>

</rules>


<project_layout>
Below is a snapshot of the current workspace's file structure at the start of the conversation. This snapshot will NOT update during the conversation.

/Users/sam/Documents/repositories/explorAI-AIClone/
  - app/
    - api/
      - chat/
        - route.ts
      - data/
        - route.ts
      - personas/
        - [id]/
          - route.ts
        - route.ts
    - dashboard/
      - client/
        - page.tsx
      - doctor/
        - page.tsx
      - layout.tsx
      - pharmacist/
        - page.tsx
      - template.tsx
    - globals.css
    - layout.tsx
    - page.tsx
    - personas/
      - page.tsx
  - CLAUDE.md
  - components/
    - ai/
      - AssistantChat.tsx
    - Chatbox.tsx
    - dashboard/
      - PharmacyInventory.tsx
    - maps/
      - ClinicMap.tsx
      - MapProvider.tsx
    - Navigation.tsx
    - PersonaEditor.tsx
    - Sidebar.tsx
    - ui/
      - Button.tsx
      - GlassCard.tsx
      - StatCard.tsx
    - WelcomeScreen.tsx
  - DESIGN_SYSTEM.md
  - dev.db
  - IMPLEMENTATION_SUMMARY.md
  - JARVIS_TRANSFORMATION.md
  - lib/
    - actions/
      - pharmacy.ts
      - prescription.ts
      - user.ts
    - ai-client.ts
    - db/
      - mock-db.ts
    - generated/
      - prisma/
        - browser.ts
        - client.ts
        - commonInputTypes.ts
        - enums.ts
        - internal/
          - class.ts
          - prismaNamespace.ts
          - prismaNamespaceBrowser.ts
        - models/
          - Inventory.ts
          - Pharmacy.ts
          - Prescription.ts
          - Product.ts
          - User.ts
        - models.ts
    - persona-manager.ts
    - prisma.ts
    - services/
      - calendar.ts
      - data-processing.ts
      - index.ts
      - letta-integration.md
      - memory.ts
      - types.ts
      - vision.ts
      - voice-conversation.ts
      - web-search.ts
    - store.ts
    - types.ts
  - LLM-Notes/
    - archive/
      - README.md
    - considerations/
      - active-considerations.md
      - backend-stack-considerations.md
      - package-dependencies-status.md
    - FRAMEWORK-GUIDE.md
    - goals/
      - active-goals.md
      - project-game-plan.md
    - notes/
      - active-notes.md
      - api-audit-streamlining.md
      - gemini-pipeline-revamp.md
      - multi-provider-ai-system.md
      - package-upgrade-summary.md
      - real-time-chat-implementation.md
      - session-2025-11-18-chat-enhancements.md
      - session-2025-11-18-persona-management-overhaul.md
    - prompt-log.md
    - tasks/
      - active-tasks.md
      - initial-setup-tasks.md
  - next-env.d.ts
  - next.config.js
  - node_modules/
  - package-lock.json
  - package.json
  - personas/
    - persona-1763588875598.json
    - tony-stark.json
  - postcss.config.js
  - prisma/
    - migrations/
      - 20251204064759_init/
        - migration.sql
      - 20251204073109_add_prescription_system/
        - migration.sql
      - migration_lock.toml
    - schema.prisma
    - seed.ts
  - prisma.config.ts
  - README.md
  - scripts/
    - verify-db.ts
  - tailwind.config.ts
  - TOOLS_AND_SERVICES.md
  - TOOLS_SETUP.md
  - tsconfig.json


</project_layout>

<git_status>
This is the git status at the start of the conversation. Note that this status is a snapshot in time, and will not update during the conversation.
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .gitignore
	modified:   LLM-Notes/notes/api-audit-streamlining.md
	modified:   LLM-Notes/notes/gemini-pipeline-revamp.md
	modified:   app/dashboard/client/page.tsx
	modified:   app/dashboard/doctor/page.tsx
	modified:   app/dashboard/pharmacist/page.tsx
	modified:   app/layout.tsx
	modified:   package-lock.json
	modified:   package.json

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	components/dashboard/
	dev.db
	lib/actions/
	lib/prisma.ts
	prisma.config.ts
	prisma/
	scripts/

no changes added to commit (use "git add" and/or "git commit -a")

</git_status>



<additional_data>
Below are some potentially helpful/relevant pieces of information for figuring out how to respond:

<open_and_recently_viewed_files>
Recently viewed files (recent at the top, oldest at the bottom):
- /Users/sam/Documents/repositories/explorAI-AIClone/personas/persona-1763588875598.json (total lines: 10)

Files that are currently open and visible in the user's IDE:
- /Users/sam/Documents/repositories/explorAI-AIClone/personas/persona-1763588875598.json (currently focused file, cursor is on line 10, total lines: 10)

Note: these files may or may not be relevant to the current conversation. Use the read_file tool if you need to get the contents of some of them.
</open_and_recently_viewed_files>
</additional_data>

<user_query>
can you clear all local deployments
</user_query>
---
2025-12-04T00:00:00Z
<additional_data>
Below are some potentially helpful/relevant pieces of information for figuring out how to respond:

<current_file>
Path: personas/persona-1763588875598.json
Currently selected line: 10
Line 10 content: ``
</current_file>
</additional_data>

<user_query>
all local dev servers and localhosts
</user_query>
---
2025-12-09T19:47:29Z
<user_query>
relaunch app
</user_query>
---
